{"version":3,"sources":["Auth.js"],"names":["bcrypt","require","User","config","exports","signup","req","res","_req$body","name","email","password","role","hashedPassword","user","regeneratorRuntime","async","_context","prev","next","body","awrap","findOne","sent","abrupt","status","json","success","message","hash","t0","existingUser","create","data","t1","stop","payload","_id","compare","token","jwt","sign","process","env","JWT_SECRET","expiresIn","toObject","undefined","options","expires","Date","now","httpOnly","cookie","console","error","_context2"],"mappings":"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","file":"Auth.min.js","sourcesContent":["const bcrypt = require('bcrypt');\nconst User = require(\"../Models/User\");\nconst jwt = require(\"jsonwebtoken\")\n\nrequire(\"dotenv\").config()\n\n// Sign up route handler\nexports.signup = async (req, res) => {\n    try {\n        // get data\n        const { name, email, password, role } = req.body;\n\n        // check if user already exist \n        const existingUser = await User.findOne({ email });\n\n        if (existingUser) {\n            return res.status(400).json({\n                success: false,\n                message: \"User Already Exists\",\n            })\n        }\n\n        // Secured password \n        let hashedPassword;\n        try {\n            hashedPassword = await bcrypt.hash(password, 10);\n        }\n        catch (err) {\n            return res.status(500).json({\n                success: false,\n                message: \"Error in hashing password\",\n            })\n        }\n\n        // Create Entry for User\n        let user = await User.create({\n            name,email,password:hashedPassword,role\n        });\n\n        return res.status(200).json({\n            success : true,\n            message : \"User Created Successfully\",\n            data : user\n        });\n    }\n    catch (err) {\n        console.error(err)\n        return res.status(500).json({\n            success: false,\n            message: \"User cannot be register,Please try again later\",\n        })\n    }\n}\n\n// Login\nexports.login = async (req,res) => {\n    try\n    {\n        const {email,password} = req.body;\n        if(!email || !password)\n        {\n            return res.status(400).json({\n                success:false,\n                message : \"Please fill all the details carefully\",\n            })\n        }\n\n        // check for register user \n        let user = await User.findOne({email});\n        if(!user)\n        {\n            return res.status(401).json({\n                success : false,\n                message : \"User does not exist\",\n            });\n        }\n\n        // Verify password & generate a JWT token\n\n        const payload = {\n            email : user.email,\n            id : user._id,\n            role : user.role,\n        };\n\n\n        if(await bcrypt.compare(password,user.password)){\n            // password match\n            let token = jwt.sign(payload,process.env.JWT_SECRET,{\n                expiresIn : \"2h\",\n            });\n\n            user = user.toObject();\n            user.token = token;\n            user.password = undefined;\n\n            const options = {\n                expires : new Date(Date.now() + 3 * 24 * 60 * 60 * 1000),\n                httpOnly : true,\n            }\n\n            res.cookie(\"token\",token,options).status(200).json({\n                success : true,\n                token,\n                user,\n                message:\"User logged in successfully\"\n            });\n        }\n        else {\n            // password not match\n            return res.status(403).json({\n                success : false,\n                message : \"Password does not match\",\n            })\n        }\n    }\n    catch(err){\n        console.error(err)\n        return res.status(500).json({\n            success : false,\n            message : \"Login false\" \n        })\n    }\n}"]}